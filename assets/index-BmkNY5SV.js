var g=Object.defineProperty;var v=(s,e,t)=>e in s?g(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var h=(s,e,t)=>v(s,typeof e!="symbol"?e+"":e,t);import{i as f,C as w,I as x,a as D}from"./index-UH2Wy8GS.js";const C=s=>{const e=Math.floor(Math.random()*s.length);return s[e]};class B{constructor(e,t,i,r){this.x=e,this.y=t,this.width=i,this.height=r}update(e){e.left&&this.x>0&&(this.x-=5),e.right&&this.x+this.width<800&&(this.x+=5)}draw(e){e.fillStyle="blue",e.fillRect(this.x,this.y,this.width,this.height)}}class S{constructor(e,t,i=10,r=4,l=4){this.x=e,this.y=t,this.radius=i,this.dx=r,this.dy=l}getPosition(e){const t=this[e];if(typeof t!="function")return t}updatePosition(){return this.x+=this.dx,this.y+=this.dy,this}performWallCollision(e,t){(e.x-e.radius<0||e.x+e.radius>t)&&(e.dx*=-1),e.y-e.radius<0&&(e.dy*=-1)}performBallCollision(e,t){return!t.isDestroyed&&e.x>t.x&&e.x<t.x+t.width&&e.y>t.y&&e.y<t.y+t.height?(e.dy*=-1,!0):!1}performPaddleCollision(e,t){e.y+e.radius>t.y&&e.x>t.x&&e.x<t.x+t.width&&(e.dy*=-1,e.y=t.y-e.radius)}draw(e){e.fillStyle="red",e.beginPath(),e.arc(this.x,this.y,this.radius,0,Math.PI*2),e.fill(),e.closePath()}}class u{constructor(e,t,i,r){h(this,"_isDestroyed",!1);this.x=e,this.y=t,this.width=i,this.height=r}get isDestroyed(){return this._isDestroyed}draw(e){this._isDestroyed||(e.fillStyle="green",e.fillRect(this.x,this.y,this.width,this.height))}destroy(){this._isDestroyed=!0}static createBricksField(e){const t=C(e),i=75,r=20,l=10,d=50,p=35,m=[];for(let a=0;a<t.length;a++)for(let n=0;n<t[a].length;n++)t[a][n]===1&&m.push(new u(p+n*(i+l),d+a*(r+l),i,r));return m}static isAllBricksDestroyed(e){return e.every(t=>t.isDestroyed)}}const o=800,c=600,_=100,A=10,T=[[[1,0,1,0,1,0,1,0],[0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1]],[[0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0],[0,1,0,1,0,1,0,1]],[[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0],[0,0,1,1,1,1,0,0]],[[1,0,1,0,1,0,1,0],[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0]],[[1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1],[1,0,1,0,0,1,0,1]],[[1,1,1,1,1,1,1,1],[1,0,1,0,1,0,1,1],[0,1,0,1,0,1,0,1]],[[0,0,1,1,1,1,0,0],[0,1,0,0,0,0,1,0],[1,0,1,0,0,1,0,1]],[[1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,1],[1,0,1,1,1,1,0,1]],[[1,0,0,1,1,0,0,1],[0,1,1,0,0,1,1,0],[1,0,0,1,1,0,0,1]],[[0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0],[0,1,0,1,0,1,0,1]]];var H=Object.getOwnPropertyDescriptor,I=(s,e,t,i)=>{for(var r=i>1?void 0:i?H(e,t):e,l=s.length-1,d;l>=0;l--)(d=s[l])&&(r=d(r)||r);return r};let y=class{constructor(){h(this,"canvasService",f.resolve(w));h(this,"input",f.resolve(x));h(this,"bricks",u.createBricksField(T));h(this,"ball",new S(o/2,c/2));h(this,"paddle",new B(o/2-50,c-30,_,A))}init(s){this.canvasService.build(s,{width:o,height:c}),this.gameLoop()}gameLoop(){this.update(),this.rerender(),!this.isGameOver()&&requestAnimationFrame(this.gameLoop.bind(this))}update(){this.paddle.update(this.input),this.ball.updatePosition(),this.performBallCollisions(this.ball)}isGameOver(){if(this.isBallBelowPaddleOver())return alert("You lose!"),!0;if(u.isAllBricksDestroyed(this.bricks))return alert("You won!"),!0}isBallBelowPaddleOver(){const s=this.ball.getPosition("y");return s!=null&&s>c}performBallCollisions(s){this.ball.performWallCollision(s,o),this.ball.performPaddleCollision(s,this.paddle),this.bricks.forEach(e=>{this.ball.performBallCollision(s,e)&&e.destroy()})}rerender(){this.canvasService.render(this.paddle,this.ball,...this.bricks)}};y=I([D()],y);class G{constructor(){h(this,"gameService",f.resolve(y));h(this,"element");this.element=document.createElement("div"),this.gameService.init(this.element)}render(){return this.element}}export{G as GameComponent};
